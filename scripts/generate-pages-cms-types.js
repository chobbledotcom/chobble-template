/**
 * Generate PagesCMS type definitions from .pages.yml schema
 *
 * This script parses .pages.yml and generates src/_lib/types/pages-cms-generated.d.ts
 * with TypeScript interfaces for all PagesCMS-validated data types.
 *
 * Fields marked as `required: true` in .pages.yml become non-optional properties.
 * This allows JSDoc annotations to leverage PagesCMS schema validation.
 *
 * Run: bun scripts/generate-pages-cms-types.js
 */

import { readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import YAML from "yaml";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.join(__dirname, "..");
const PAGES_YML = path.join(ROOT_DIR, ".pages.yml");
const OUTPUT_FILE = path.join(
  ROOT_DIR,
  "src/_lib/types/pages-cms-generated.d.ts",
);

/**
 * Map PagesCMS field types to TypeScript types
 */
const mapFieldType = (field) => {
  if (!field.type) return "unknown";

  switch (field.type) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "date":
      return "string"; // Dates come as ISO strings
    case "object":
      return "Record<string, unknown>";
    case "image":
      return "string";
    case "code":
      return "string";
    case "reference":
      return "string"; // References store paths as strings
    default:
      return "unknown";
  }
};

/**
 * Generate an interface name from a field name
 * e.g., "product_options" -> "PagesCMSProductOption"
 */
const generateInterfaceName = (fieldName) => {
  // Remove common suffixes that indicate arrays
  const singular = fieldName
    .replace(/s$/, "") // Remove trailing 's' for plurals
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");

  return `PagesCMS${singular}`;
};

/**
 * Extract fields for a single object-type field
 */
const extractObjectFields = (field) => {
  const properties = [];

  if (field.fields) {
    for (const subField of field.fields) {
      const isRequired = subField.required === true;
      const tsType = mapFieldType(subField);

      properties.push({
        name: subField.name,
        type: tsType,
        required: isRequired,
        optional: !isRequired,
        label: subField.label || "",
      });
    }
  }

  return properties;
};

/**
 * Generate TypeScript code for an object type
 */
const generateObjectTypeCode = (interfaceName, properties) => {
  const lines = ["/**", ` * @typedef {Object} ${interfaceName}`];

  for (const prop of properties) {
    const requiredStr = prop.required ? "" : "?";
    lines.push(
      ` * @property {${prop.type}} ${requiredStr}${prop.name} - ${prop.label}`,
    );
  }

  lines.push(" */");
  lines.push(`export interface ${interfaceName} {`);

  for (const prop of properties) {
    const optionalMarker = prop.optional ? "?" : "";
    lines.push(`  ${prop.name}${optionalMarker}: ${prop.type};`);
  }

  lines.push("}");
  return lines.join("\n");
};

/**
 * Process a single field and generate type if it's an object type
 */
const processFieldType = (field, types, typeMapping) => {
  const isObjectType = field.type === "object" && field.fields;
  if (!isObjectType) return;

  // Skip if already generated
  if (typeMapping[field.name]) return;

  const interfaceName = generateInterfaceName(field.name);
  const properties = extractObjectFields(field);
  const typeCode = generateObjectTypeCode(interfaceName, properties);

  types.push({
    name: field.name,
    interfaceName,
    code: typeCode,
  });

  typeMapping[field.name] = interfaceName;
};

/**
 * Extract all types from config items
 */
const extractAllTypes = (config) => {
  const types = [];
  const typeMapping = {};

  const allItems = config.content || [];
  for (const item of allItems) {
    if (item.fields) {
      for (const field of item.fields) {
        processFieldType(field, types, typeMapping);
      }
    }
  }

  return { types, typeMapping };
};

/**
 * Generate the header for the output file
 */
const generateFileHeader = () => {
  return [
    "/**",
    " * @fileoverview Auto-generated PagesCMS types from .pages.yml",
    " *",
    " * Generated by: scripts/generate-pages-cms-types.js",
    " * Do not edit manually - regenerate using: bun scripts/generate-pages-cms-types.js",
    " *",
    " * These types represent data validated by PagesCMS schema (.pages.yml).",
    " * Fields marked as required: true in the schema are non-optional.",
    " * Use these in JSDoc annotations to leverage validation guarantees.",
    " */",
    "",
  ];
};

/**
 * Parse .pages.yml and generate type definitions
 */
const generateTypes = () => {
  const yamlContent = readFileSync(PAGES_YML, "utf-8");
  const config = YAML.parse(yamlContent);

  const { types } = extractAllTypes(config);

  const output = [
    ...generateFileHeader(),
    ...types.flatMap((type) => [type.code, ""]),
  ];

  // Write the file
  writeFileSync(OUTPUT_FILE, `${output.join("\n")}\n`);
  console.log(`✓ Generated types to ${OUTPUT_FILE}`);
  console.log(`✓ Generated ${types.length} type interfaces`);
};

generateTypes();
